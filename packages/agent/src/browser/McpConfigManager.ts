import { readFile, writeFile, unlink, mkdir } from 'fs/promises';
import { join, dirname } from 'path';

const MANAGED_MARKER = '_VIBEPILOT_MANAGED';

const MANAGED_SERVERS: Record<
  string,
  {
    command: string;
    buildArgs: (cdpUrl: string) => string[];
  }
> = {
  'vibepilot-playwright': {
    command: 'npx',
    buildArgs: (cdpUrl) => ['-y', '@playwright/mcp@latest', '--cdp-endpoint', cdpUrl],
  },
  'vibepilot-devtools': {
    command: 'npx',
    buildArgs: (cdpUrl) => ['-y', 'chrome-devtools-mcp@latest', '--browserUrl', cdpUrl],
  },
};

const CLAUDE_LOCAL_MD_CONTENT = `<!-- VIBEPILOT_MANAGED: This file is auto-generated by VibePilot. Do not edit manually. -->
# VibePilot Browser Preview

VibePilot Preview is running. A shared Chrome instance is available via CDP.

- Use the CDP endpoint from the environment variable \`CHROME_CDP_URL\` to connect.
- Do NOT launch your own browser — reuse the existing Chrome instance.
`;

interface McpServerEntry {
  command: string;
  args: string[];
  env?: Record<string, string>;
}

interface SettingsJson {
  mcpServers?: Record<string, McpServerEntry>;
  [key: string]: unknown;
}

export class McpConfigManager {
  private settingsPath: string;
  private claudeLocalMdPath: string;

  constructor(projectPath: string) {
    this.settingsPath = join(projectPath, '.claude', 'settings.local.json');
    this.claudeLocalMdPath = join(projectPath, '.claude', 'CLAUDE.local.md');
  }

  async write(cdpUrl: string): Promise<void> {
    await mkdir(dirname(this.settingsPath), { recursive: true });

    const existing = await this.readExisting();
    if (!existing.mcpServers) {
      existing.mcpServers = {};
    }
    for (const [name, def] of Object.entries(MANAGED_SERVERS)) {
      existing.mcpServers[name] = {
        command: def.command,
        args: def.buildArgs(cdpUrl),
        env: { [MANAGED_MARKER]: 'true' },
      };
    }
    await writeFile(this.settingsPath, JSON.stringify(existing, null, 2), 'utf-8');

    // Write CLAUDE.local.md
    await writeFile(this.claudeLocalMdPath, CLAUDE_LOCAL_MD_CONTENT, 'utf-8');
  }

  async clean(): Promise<void> {
    // Clean settings.local.json — only remove managed mcpServers
    try {
      const config = await this.readExisting();
      if (!config.mcpServers) return;

      let hasManaged = false;
      for (const [name, entry] of Object.entries(config.mcpServers)) {
        if (entry.env?.[MANAGED_MARKER] === 'true') {
          delete config.mcpServers[name];
          hasManaged = true;
        }
      }

      if (!hasManaged) return;

      if (Object.keys(config.mcpServers).length === 0) {
        delete config.mcpServers;
      }

      // Always rewrite settings (never delete — other settings like outputStyle may exist)
      await writeFile(this.settingsPath, JSON.stringify(config, null, 2), 'utf-8');
    } catch {
      // File doesn't exist, nothing to clean
    }

    // Remove CLAUDE.local.md if it's ours
    try {
      const content = await readFile(this.claudeLocalMdPath, 'utf-8');
      if (content.includes('VIBEPILOT_MANAGED')) {
        await unlink(this.claudeLocalMdPath);
      }
    } catch {
      // File doesn't exist
    }
  }

  private async readExisting(): Promise<SettingsJson> {
    try {
      const raw = await readFile(this.settingsPath, 'utf-8');
      return JSON.parse(raw);
    } catch {
      return {};
    }
  }
}
